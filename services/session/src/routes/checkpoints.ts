// Session checkpoint API routes
// REST API endpoints for checkpoint management

import { Elysia, t } from 'elysia';

import { sessionCheckpointService } from '../services/checkpoint.service.js';
import { sessionService } from '../services/session.service.js';
import type {
  CheckpointFilter,
  CreateCheckpointOptions,
  CreateCheckpointRequest,
  UpdateCheckpointRequest} from '../types/session.js';

// Request/Response schemas for validation
const createCheckpointSchema = t.Object({
  name: t.String({ minLength: 1, maxLength: 100 }),
  description: t.Optional(t.String({ maxLength: 500 })),
  tags: t.Optional(t.Array(t.String({ maxLength: 50 }))),
  priority: t.Optional(t.Enum(['low', 'medium', 'high'])),
  workspaceState: t.Object({
    terminalState: t.Array(t.Any()),
    browserTabs: t.Array(t.Any()),
    aiConversations: t.Array(t.Any()),
    openFiles: t.Array(t.Any()),
    workspaceConfig: t.Optional(t.Object({})),
    metadata: t.Optional(t.Object({}))
  }),
  encryptData: t.Optional(t.Boolean()),
  encryptionKey: t.Optional(t.String()),
  skipDuplicates: t.Optional(t.Boolean())
});

const updateCheckpointSchema = t.Object({
  name: t.Optional(t.String({ minLength: 1, maxLength: 100 })),
  description: t.Optional(t.String({ maxLength: 500 })),
  tags: t.Optional(t.Array(t.String({ maxLength: 50 }))),
  priority: t.Optional(t.Enum(['low', 'medium', 'high'])),
  metadata: t.Optional(t.Object({}))
});

const checkpointFilterSchema = t.Object({
  sessionId: t.Optional(t.String()),
  tags: t.Optional(t.Array(t.String())),
  dateFrom: t.Optional(t.Date()),
  dateTo: t.Optional(t.Date()),
  priority: t.Optional(t.Enum(['low', 'medium', 'high'])),
  isAutoGenerated: t.Optional(t.Boolean()),
  limit: t.Optional(t.Integer({ minimum: 1, maximum: 100 })),
  offset: t.Optional(t.Integer({ minimum: 0 })),
  sortBy: t.Optional(t.Enum(['createdAt', 'name', 'size', 'priority'])),
  sortOrder: t.Optional(t.Enum(['asc', 'desc']))
});

const restoreCheckpointSchema = t.Object({
  encryptionKey: t.Optional(t.String()),
  createBackup: t.Optional(t.Boolean()),
  backupName: t.Optional(t.String({ maxLength: 100 }))
});

const deleteCheckpointsSchema = t.Object({
  checkpointIds: t.Array(t.String({ minLength: 1 }))
});

const cleanupCheckpointsSchema = t.Object({
  retentionDays: t.Optional(t.Integer({ minimum: 1, maximum: 365 })),
  keepCount: t.Optional(t.Integer({ minimum: 1, maximum: 100 })),
  priority: t.Optional(t.Array(t.Enum(['low', 'medium', 'high']))),
  dryRun: t.Optional(t.Boolean())
});

/**
 * Checkpoint routes plugin
 */
export const checkpointRoutes = new Elysia({ prefix: '/checkpoints' })
  .group('/v1', (app) =>
    app
      // Create checkpoint
      .post('/', async ({ body, set }) => {
        try {
          const {
            sessionId,
            name,
            description,
            tags,
            priority,
            workspaceState,
            encryptData,
            encryptionKey,
            skipDuplicates
          } = body;

          // Validate session exists (basic check without decryption)
          try {
            await sessionService.getSession(sessionId, encryptionKey);
          } catch (error) {
            if (error instanceof Error && error.message.includes('not found')) {
              set.status = 404;
              return {
                success: false,
                error: 'Session not found',
                code: 'SESSION_NOT_FOUND'
              };
            }
            // Continue even if decryption fails - we just need to verify session exists
          }

          // Create checkpoint
          const checkpoint = await sessionCheckpointService.createCheckpoint(
            sessionId,
            workspaceState,
            {
              name,
              description,
              tags,
              priority
            },
            {
              encryptData,
              encryptionKey,
              skipDuplicates,
              validateState: true
            }
          );

          set.status = 201;
          return {
            success: true,
            data: checkpoint,
            message: 'Checkpoint created successfully'
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_CREATE_FAILED'
          };
        }
      }, {
        body: t.Object({
          sessionId: t.String(),
          ...createCheckpointSchema.properties
        }),
        detail: 'Create a new checkpoint for a session'
      })

      // List checkpoints with filtering
      .get('/', async ({ query, set }) => {
        try {
          const filter: CheckpointFilter = {
            sessionId: query.sessionId,
            tags: query.tags,
            dateFrom: query.dateFrom ? new Date(query.dateFrom) : undefined,
            dateTo: query.dateTo ? new Date(query.dateTo) : undefined,
            priority: query.priority,
            isAutoGenerated: query.isAutoGenerated,
            limit: query.limit || 20,
            offset: query.offset || 0,
            sortBy: query.sortBy || 'createdAt',
            sortOrder: query.sortOrder || 'desc'
          };

          const result = await sessionCheckpointService.getCheckpoints(filter);

          return {
            success: true,
            data: result,
            message: 'Checkpoints retrieved successfully'
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINTS_LIST_FAILED'
          };
        }
      }, {
        query: checkpointFilterSchema,
        detail: 'List checkpoints with filtering and pagination'
      })

      // Get specific checkpoint
      .get('/:checkpointId', async ({ params, set }) => {
        try {
          const checkpoint = await sessionCheckpointService.getCheckpoint(params.checkpointId);

          return {
            success: true,
            data: checkpoint,
            message: 'Checkpoint retrieved successfully'
          };
        } catch (error) {
          if (error instanceof Error && error.message.includes('not found')) {
            set.status = 404;
            return {
              success: false,
              error: 'Checkpoint not found',
              code: 'CHECKPOINT_NOT_FOUND'
            };
          }

          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_GET_FAILED'
          };
        }
      }, {
        params: t.Object({
          checkpointId: t.String()
        }),
        detail: 'Get a specific checkpoint by ID'
      })

      // Update checkpoint metadata
      .put('/:checkpointId', async ({ params, body, set }) => {
        try {
          const checkpoint = await sessionCheckpointService.updateCheckpoint(
            params.checkpointId,
            body
          );

          return {
            success: true,
            data: checkpoint,
            message: 'Checkpoint updated successfully'
          };
        } catch (error) {
          if (error instanceof Error && error.message.includes('not found')) {
            set.status = 404;
            return {
              success: false,
              error: 'Checkpoint not found',
              code: 'CHECKPOINT_NOT_FOUND'
            };
          }

          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_UPDATE_FAILED'
          };
        }
      }, {
        params: t.Object({
          checkpointId: t.String()
        }),
        body: updateCheckpointSchema,
        detail: 'Update checkpoint metadata'
      })

      // Delete checkpoint
      .delete('/:checkpointId', async ({ params, set }) => {
        try {
          await sessionCheckpointService.deleteCheckpoint(params.checkpointId);

          return {
            success: true,
            message: 'Checkpoint deleted successfully'
          };
        } catch (error) {
          if (error instanceof Error && error.message.includes('not found')) {
            set.status = 404;
            return {
              success: false,
              error: 'Checkpoint not found',
              code: 'CHECKPOINT_NOT_FOUND'
            };
          }

          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_DELETE_FAILED'
          };
        }
      }, {
        params: t.Object({
          checkpointId: t.String()
        }),
        detail: 'Delete a checkpoint'
      })

      // Delete multiple checkpoints
      .post('/delete-batch', async ({ body, set }) => {
        try {
          const result = await sessionCheckpointService.deleteCheckpoints(body.checkpointIds);

          return {
            success: true,
            data: result,
            message: `Deleted ${result.deleted} checkpoints successfully`
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINTS_DELETE_BATCH_FAILED'
          };
        }
      }, {
        body: deleteCheckpointsSchema,
        detail: 'Delete multiple checkpoints'
      })

      // Restore session from checkpoint
      .post('/:checkpointId/restore', async ({ params, body, set }) => {
        try {
          const result = await sessionCheckpointService.restoreFromCheckpoint(
            params.checkpointId,
            {
              encryptionKey: body.encryptionKey,
              createBackup: body.createBackup,
              backupName: body.backupName
            }
          );

          return {
            success: true,
            data: {
              session: result.session,
              backupCheckpoint: result.backupCheckpoint
            },
            workspaceState: result.workspaceState,
            message: 'Session restored from checkpoint successfully'
          };
        } catch (error) {
          if (error instanceof Error && error.message.includes('not found')) {
            set.status = 404;
            return {
              success: false,
              error: 'Checkpoint not found',
              code: 'CHECKPOINT_NOT_FOUND'
            };
          }

          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_RESTORE_FAILED'
          };
        }
      }, {
        params: t.Object({
          checkpointId: t.String()
        }),
        body: restoreCheckpointSchema,
        detail: 'Restore session from checkpoint'
      })

      // Get checkpoint statistics
      .get('/stats/:sessionId?', async ({ params, set }) => {
        try {
          const sessionId = params.sessionId;
          const stats = await sessionCheckpointService.getCheckpointStatistics(sessionId);

          return {
            success: true,
            data: stats,
            message: 'Checkpoint statistics retrieved successfully'
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_STATS_FAILED'
          };
        }
      }, {
        params: t.Object({
          sessionId: t.Optional(t.String())
        }),
        detail: 'Get checkpoint statistics for a session or globally'
      })

      // Clean up old checkpoints
      .post('/cleanup', async ({ body, set }) => {
        try {
          const result = await sessionCheckpointService.cleanupOldCheckpoints({
            retentionDays: body.retentionDays,
            keepCount: body.keepCount,
            priority: body.priority,
            dryRun: body.dryRun || false
          });

          const message = body.dryRun
            ? `Found ${result.deletedCount} checkpoints to delete (${(result.freedSpace / 1024 / 1024).toFixed(2)} MB)`
            : `Deleted ${result.deletedCount} checkpoints and freed ${(result.freedSpace / 1024 / 1024).toFixed(2)} MB`;

          return {
            success: true,
            data: result,
            message
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'CHECKPOINT_CLEANUP_FAILED'
          };
        }
      }, {
        body: cleanupCheckpointsSchema,
        detail: 'Clean up old checkpoints based on retention policy'
      })

      // Get checkpoints for a specific session
      .get('/session/:sessionId', async ({ params, query, set }) => {
        try {
          const filter: CheckpointFilter = {
            sessionId: params.sessionId,
            tags: query.tags,
            dateFrom: query.dateFrom ? new Date(query.dateFrom) : undefined,
            dateTo: query.dateTo ? new Date(query.dateTo) : undefined,
            priority: query.priority,
            isAutoGenerated: query.isAutoGenerated,
            limit: query.limit || 20,
            offset: query.offset || 0,
            sortBy: query.sortBy || 'createdAt',
            sortOrder: query.sortOrder || 'desc'
          };

          const result = await sessionCheckpointService.getCheckpoints(filter);

          return {
            success: true,
            data: result,
            message: 'Session checkpoints retrieved successfully'
          };
        } catch (error) {
          set.status = 400;
          return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            code: 'SESSION_CHECKPOINTS_FAILED'
          };
        }
      }, {
        params: t.Object({
          sessionId: t.String()
        }),
        query: t.Partial(checkpointFilterSchema),
        detail: 'Get checkpoints for a specific session'
      })
  )

  // Health check endpoint
  .get('/health', async () => {
    return {
      success: true,
      status: 'healthy',
      service: 'checkpoint-service',
      timestamp: new Date().toISOString()
    };
  });

export default checkpointRoutes;