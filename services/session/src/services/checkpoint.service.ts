// Session checkpoint management service
// Handles manual checkpoint creation, listing, deletion, and restoration workflows


import { generateChecksum } from '../lib/encryption.js';
import prisma from '../lib/prisma.js';
import { createSerializer,SessionStateSerializer } from '../lib/state-serializer.js';
import type {
  CheckpointListResponse,
  CheckpointResponse,
  CreateCheckpointRequest,
  SessionResponse,
  UpdateCheckpointRequest,
  WorkspaceState
} from '../types/session.js';

// Checkpoint configuration
const CHECKPOINT_CONFIG = {
  maxNameLength: 100,
  maxDescriptionLength: 500,
  defaultRetentionDays: 90,
  maxCheckpointsPerSession: 50,
  compressionEnabled: true,
  validateBeforeCreate: true
};

/**
 * Checkpoint metadata for creation and updates
 */
export interface CheckpointMetadata {
  name: string;
  description?: string;
  tags?: string[];
  isAutoGenerated?: boolean;
  priority?: 'low' | 'medium' | 'high';
}

/**
 * Checkpoint creation options
 */
export interface CreateCheckpointOptions {
  encryptData?: boolean;
  encryptionKey?: string;
  validateState?: boolean;
  skipDuplicates?: boolean;
  tags?: string[];
}

/**
 * Checkpoint filtering options
 */
export interface CheckpointFilter {
  sessionId?: string;
  tags?: string[];
  dateFrom?: Date;
  dateTo?: Date;
  priority?: 'low' | 'medium' | 'high';
  isAutoGenerated?: boolean;
  limit?: number;
  offset?: number;
  sortBy?: 'createdAt' | 'name' | 'size' | 'priority';
  sortOrder?: 'asc' | 'desc';
}

/**
 * Checkpoint statistics
 */
export interface CheckpointStatistics {
  totalCheckpoints: number;
  totalSize: number;
  averageSize: number;
  oldestCheckpoint?: Date;
  newestCheckpoint?: Date;
  checkpointsByPriority: Record<string, number>;
  checkpointsByTag: Record<string, number>;
  storageUsage: {
    compressed: number;
    uncompressed: number;
    compressionRatio: number;
  };
}

/**
 * Session checkpoint service class
 */
export class SessionCheckpointService {
  private serializer: SessionStateSerializer;

  /**
   *
   * @param config
   */
  constructor(config?: Partial<typeof CHECKPOINT_CONFIG>) {
    this.serializer = createSerializer();
  }

  /**
   * Create a new checkpoint for a session
   * @param sessionId
   * @param workspaceState
   * @param metadata
   * @param options
   */
  async createCheckpoint(
    sessionId: string,
    workspaceState: WorkspaceState,
    metadata: CheckpointMetadata,
    options: CreateCheckpointOptions = {}
  ): Promise<CheckpointResponse> {
    try {
      // Validate inputs
      await this.validateCheckpointInputs(sessionId, workspaceState, metadata, options);

      // Check for duplicate checkpoints if requested
      if (options.skipDuplicates) {
        const existingCheckpoint = await this.findDuplicateCheckpoint(sessionId, metadata.name);
        if (existingCheckpoint) {
          throw new Error(`Checkpoint with name '${metadata.name}' already exists`);
        }
      }

      // Get session to verify it exists and get user info
      const session = await prisma.workspaceSession.findUnique({
        where: { id: sessionId },
        select: {
          id: true,
          userId: true,
          workspaceId: true,
          name: true
        }
      });

      if (!session) {
        throw new Error('Session not found');
      }

      // Check checkpoint limit
      const checkpointCount = await prisma.sessionCheckpoint.count({
        where: { sessionId }
      });

      if (checkpointCount >= CHECKPOINT_CONFIG.maxCheckpointsPerSession) {
        // Remove oldest checkpoint to make room
        await this.removeOldestCheckpoint(sessionId);
      }

      // Serialize and optionally encrypt the workspace state
      const serializedData = await this.serializeWorkspaceState(
        workspaceState,
        options.encryptData,
        options.encryptionKey
      );

      // Generate checksum for data integrity
      const checksum = await generateChecksum(serializedData.data);

      // Create the checkpoint
      const checkpoint = await prisma.sessionCheckpoint.create({
        data: {
          sessionId,
          name: metadata.name,
          description: metadata.description || null,
          workspaceState: serializedData.data,
          stateChecksum: checksum,
          compressedSize: serializedData.compressedSize,
          uncompressedSize: serializedData.uncompressedSize,
          encryptedKey: options.encryptData ? options.encryptionKey : null,
          tags: metadata.tags || [],
          isAutoGenerated: metadata.isAutoGenerated || false,
          priority: metadata.priority || 'medium',
          metadata: {
            createdAt: new Date(),
            version: '1.0',
            source: 'manual',
            ...metadata
          }
        }
      });

      // Update session metadata
      await this.updateSessionCheckpointCount(sessionId);

      return this.mapToCheckpointResponse(checkpoint);
    } catch (error) {
      throw new Error(`Failed to create checkpoint: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get list of checkpoints with filtering and pagination
   * @param filter
   */
  async getCheckpoints(filter: CheckpointFilter = {}): Promise<CheckpointListResponse> {
    try {
      const {
        sessionId,
        tags,
        dateFrom,
        dateTo,
        priority,
        isAutoGenerated,
        limit = 20,
        offset = 0,
        sortBy = 'createdAt',
        sortOrder = 'desc'
      } = filter;

      // Build where clause
      const where: any = {};

      if (sessionId) {
        where.sessionId = sessionId;
      }

      if (tags && tags.length > 0) {
        where.tags = {
          hasSome: tags
        };
      }

      if (dateFrom || dateTo) {
        where.createdAt = {};
        if (dateFrom) {
          where.createdAt.gte = dateFrom;
        }
        if (dateTo) {
          where.createdAt.lte = dateTo;
        }
      }

      if (priority) {
        where.priority = priority;
      }

      if (typeof isAutoGenerated === 'boolean') {
        where.isAutoGenerated = isAutoGenerated;
      }

      // Get total count
      const total = await prisma.sessionCheckpoint.count({ where });

      // Get checkpoints with pagination
      // Map sortBy field names to database fields
      const orderByField = sortBy === 'size' ? 'compressedSize' : sortBy;

      const checkpoints = await prisma.sessionCheckpoint.findMany({
        where,
        include: {
          session: {
            select: {
              id: true,
              name: true,
              workspaceId: true
            }
          }
        },
        orderBy: { [orderByField]: sortOrder },
        take: limit,
        skip: offset
      });

      return {
        checkpoints: checkpoints.map(cp => this.mapToCheckpointResponse(cp)),
        pagination: {
          total,
          limit,
          offset,
          hasMore: offset + limit < total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      throw new Error(`Failed to get checkpoints: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get a specific checkpoint by ID
   * @param checkpointId
   */
  async getCheckpoint(checkpointId: string): Promise<CheckpointResponse> {
    try {
      const checkpoint = await prisma.sessionCheckpoint.findUnique({
        where: { id: checkpointId },
        include: {
          session: {
            select: {
              id: true,
              name: true,
              workspaceId: true,
              userId: true
            }
          }
        }
      });

      if (!checkpoint) {
        throw new Error('Checkpoint not found');
      }

      return this.mapToCheckpointResponse(checkpoint);
    } catch (error) {
      throw new Error(`Failed to get checkpoint: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Update checkpoint metadata
   * @param checkpointId
   * @param updates
   */
  async updateCheckpoint(
    checkpointId: string,
    updates: UpdateCheckpointRequest
  ): Promise<CheckpointResponse> {
    try {
      // Validate checkpoint exists
      const existingCheckpoint = await prisma.sessionCheckpoint.findUnique({
        where: { id: checkpointId }
      });

      if (!existingCheckpoint) {
        throw new Error('Checkpoint not found');
      }

      // Validate updates
      if (updates.name && updates.name.length > CHECKPOINT_CONFIG.maxNameLength) {
        throw new Error(`Checkpoint name too long (max ${CHECKPOINT_CONFIG.maxNameLength} characters)`);
      }

      if (updates.description && updates.description.length > CHECKPOINT_CONFIG.maxDescriptionLength) {
        throw new Error(`Checkpoint description too long (max ${CHECKPOINT_CONFIG.maxDescriptionLength} characters)`);
      }

      // Update checkpoint
      const updatedCheckpoint = await prisma.sessionCheckpoint.update({
        where: { id: checkpointId },
        data: {
          ...(updates.name && { name: updates.name }),
          ...(updates.description !== undefined && { description: updates.description }),
          ...(updates.tags && { tags: updates.tags }),
          ...(updates.priority && { priority: updates.priority }),
          metadata: {
            ...existingCheckpoint.metadata as any,
            ...updates.metadata,
            updatedAt: new Date()
          }
        },
        include: {
          session: {
            select: {
              id: true,
              name: true,
              workspaceId: true,
              userId: true
            }
          }
        }
      });

      return this.mapToCheckpointResponse(updatedCheckpoint);
    } catch (error) {
      throw new Error(`Failed to update checkpoint: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Delete a checkpoint
   * @param checkpointId
   */
  async deleteCheckpoint(checkpointId: string): Promise<void> {
    try {
      // Verify checkpoint exists and get session ID
      const checkpoint = await prisma.sessionCheckpoint.findUnique({
        where: { id: checkpointId },
        select: { sessionId: true }
      });

      if (!checkpoint) {
        throw new Error('Checkpoint not found');
      }

      // Delete the checkpoint
      await prisma.sessionCheckpoint.delete({
        where: { id: checkpointId }
      });

      // Update session checkpoint count
      await this.updateSessionCheckpointCount(checkpoint.sessionId);
    } catch (error) {
      throw new Error(`Failed to delete checkpoint: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Delete multiple checkpoints
   * @param checkpointIds
   */
  async deleteCheckpoints(checkpointIds: string[]): Promise<{ deleted: number; errors: string[] }> {
    const result = {
      deleted: 0,
      errors: [] as string[]
    };

    for (const checkpointId of checkpointIds) {
      try {
        await this.deleteCheckpoint(checkpointId);
        result.deleted++;
      } catch (error) {
        result.errors.push(`Failed to delete checkpoint ${checkpointId}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return result;
  }

  /**
   * Restore session from checkpoint
   * @param checkpointId
   * @param options
   * @param options.encryptionKey
   * @param options.createBackup
   * @param options.backupName
   */
  async restoreFromCheckpoint(
    checkpointId: string,
    options: {
      encryptionKey?: string;
      createBackup?: boolean;
      backupName?: string;
    } = {}
  ): Promise<{
    session: SessionResponse;
    workspaceState: WorkspaceState;
    backupCheckpoint?: CheckpointResponse;
  }> {
    try {
      // Get checkpoint with session info
      const checkpoint = await prisma.sessionCheckpoint.findUnique({
        where: { id: checkpointId },
        include: {
          session: true
        }
      });

      if (!checkpoint) {
        throw new Error('Checkpoint not found');
      }

      // Create backup if requested
      let backupCheckpoint: CheckpointResponse | undefined;
      if (options.createBackup) {
        const currentSessionState = await this.getCurrentSessionState(checkpoint.sessionId);
        if (currentSessionState) {
          backupCheckpoint = await this.createCheckpoint(
            checkpoint.sessionId,
            currentSessionState,
            {
              name: options.backupName || `Backup before restore - ${new Date().toISOString()}`,
              description: 'Automatic backup created before checkpoint restoration',
              isAutoGenerated: true,
              priority: 'low'
            }
          );
        }
      }

      // Deserialize workspace state from checkpoint
      const workspaceState = await this.serializer.deserializeState(
        checkpoint.workspaceState as any,
        checkpoint.stateChecksum,
        options.encryptionKey
      );

      // Update session with checkpoint data
      const updatedSession = await prisma.workspaceSession.update({
        where: { id: checkpoint.sessionId },
        data: {
          workspaceState: checkpoint.workspaceState,
          stateChecksum: checkpoint.stateChecksum,
          lastSavedAt: new Date(),
          version: { increment: 1 }
        }
      });

      // Update checkpoint restore count
      await prisma.sessionCheckpoint.update({
        where: { id: checkpointId },
        data: {
          metadata: {
            ...(checkpoint.metadata as any),
            lastRestoredAt: new Date(),
            restoreCount: ((checkpoint.metadata as any)?.restoreCount || 0) + 1
          }
        }
      });

      return {
        session: this.mapToSessionResponse(updatedSession),
        workspaceState,
        backupCheckpoint
      };
    } catch (error) {
      throw new Error(`Failed to restore from checkpoint: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get checkpoint statistics
   * @param sessionId
   */
  async getCheckpointStatistics(sessionId?: string): Promise<CheckpointStatistics> {
    try {
      const where = sessionId ? { sessionId } : {};

      const [
        totalCheckpoints,
        checkpoints,
        storageData
      ] = await Promise.all([
        prisma.sessionCheckpoint.count({ where }),
        prisma.sessionCheckpoint.findMany({
          where,
          select: {
            compressedSize: true,
            uncompressedSize: true,
            createdAt: true,
            priority: true,
            tags: true
          },
          orderBy: { createdAt: 'asc' }
        }),
        prisma.sessionCheckpoint.aggregate({
          where,
          _sum: {
            compressedSize: true,
            uncompressedSize: true
          },
          _avg: {
            compressedSize: true
          }
        })
      ]);

      const totalSize = storageData._sum.compressedSize || 0;
      const uncompressedSize = storageData._sum.uncompressedSize || 0;
      const averageSize = storageData._avg.compressedSize || 0;

      // Calculate priority distribution
      const checkpointsByPriority: Record<string, number> = {
        low: 0,
        medium: 0,
        high: 0
      };

      // Calculate tag distribution
      const checkpointsByTag: Record<string, number> = {};

      for (const checkpoint of checkpoints) {
        // Priority distribution
        if (checkpoint.priority in checkpointsByPriority) {
          checkpointsByPriority[checkpoint.priority]++;
        }

        // Tag distribution
        for (const tag of checkpoint.tags) {
          checkpointsByTag[tag] = (checkpointsByTag[tag] || 0) + 1;
        }
      }

      return {
        totalCheckpoints,
        totalSize,
        averageSize,
        oldestCheckpoint: checkpoints[0]?.createdAt,
        newestCheckpoint: checkpoints[checkpoints.length - 1]?.createdAt,
        checkpointsByPriority,
        checkpointsByTag,
        storageUsage: {
          compressed: totalSize,
          uncompressed: uncompressedSize,
          compressionRatio: uncompressedSize > 0 ? totalSize / uncompressedSize : 1
        }
      };
    } catch (error) {
      throw new Error(`Failed to get checkpoint statistics: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Clean up old checkpoints based on retention policy
   * @param options
   * @param options.retentionDays
   * @param options.keepCount
   * @param options.priority
   * @param options.dryRun
   */
  async cleanupOldCheckpoints(
    options: {
      retentionDays?: number;
      keepCount?: number;
      priority?: Array<'low' | 'medium' | 'high'>;
      dryRun?: boolean;
    } = {}
  ): Promise<{
    deletedCount: number;
    freedSpace: number;
    deletedCheckpoints: Array<{ id: string; name: string; size: number }>;
  }> {
    const {
      retentionDays = CHECKPOINT_CONFIG.defaultRetentionDays,
      keepCount = 10,
      priority = ['low'],
      dryRun = false
    } = options;

    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

      // Find checkpoints to delete
      const checkpointsToDelete = await prisma.sessionCheckpoint.findMany({
        where: {
          createdAt: { lt: cutoffDate },
          priority: { in: priority }
        },
        select: {
          id: true,
          name: true,
          compressedSize: true,
          sessionId: true,
          createdAt: true
        },
        orderBy: { createdAt: 'asc' }
      });

      // Keep the most recent checkpoints per session
      const checkpointsBySession = new Map<string, any[]>();
      for (const checkpoint of checkpointsToDelete) {
        if (!checkpointsBySession.has(checkpoint.sessionId)) {
          checkpointsBySession.set(checkpoint.sessionId, []);
        }
        checkpointsBySession.get(checkpoint.sessionId)!.push(checkpoint);
      }

      const finalDeleteList: any[] = [];
      for (const sessionCheckpoints of checkpointsBySession) {
        // Sort by creation date (newest first) and keep the most recent ones
        sessionCheckpoints.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

        const toDelete = sessionCheckpoints.slice(keepCount);
        finalDeleteList.push(...toDelete);
      }

      if (dryRun) {
        return {
          deletedCount: finalDeleteList.length,
          freedSpace: finalDeleteList.reduce((sum, cp) => sum + (cp.compressedSize || 0), 0),
          deletedCheckpoints: finalDeleteList.map(cp => ({
            id: cp.id,
            name: cp.name,
            size: cp.compressedSize || 0
          }))
        };
      }

      // Delete checkpoints
      let deletedCount = 0;
      let freedSpace = 0;
      const deletedCheckpoints: Array<{ id: string; name: string; size: number }> = [];

      for (const checkpoint of finalDeleteList) {
        try {
          await prisma.sessionCheckpoint.delete({
            where: { id: checkpoint.id }
          });
          deletedCount++;
          freedSpace += checkpoint.compressedSize || 0;
          deletedCheckpoints.push({
            id: checkpoint.id,
            name: checkpoint.name,
            size: checkpoint.compressedSize || 0
          });
        } catch (error) {
          console.error(`Failed to delete checkpoint ${checkpoint.id}:`, error);
        }
      }

      return {
        deletedCount,
        freedSpace,
        deletedCheckpoints
      };
    } catch (error) {
      throw new Error(`Failed to cleanup old checkpoints: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate checkpoint inputs
   * @param sessionId
   * @param workspaceState
   * @param metadata
   * @param options
   */
  private async validateCheckpointInputs(
    sessionId: string,
    workspaceState: WorkspaceState,
    metadata: CheckpointMetadata,
    options: CreateCheckpointOptions
  ): Promise<void> {
    // Validate session ID - check for null, undefined, empty string, whitespace only, and non-string types
    if (sessionId === null || sessionId === undefined || typeof sessionId !== 'string' || sessionId.trim() === '') {
      throw new Error('Valid session ID is required');
    }

    // Validate workspace state
    if (!workspaceState || typeof workspaceState !== 'object') {
      throw new Error('Valid workspace state is required');
    }

    // Validate metadata - check for null, undefined, empty string, whitespace only, and non-string types
    if (metadata === null || metadata === undefined || typeof metadata !== 'object') {
      throw new Error('Checkpoint name is required');
    }

    if (!metadata.name || typeof metadata.name !== 'string' || metadata.name.trim() === '') {
      throw new Error('Checkpoint name is required');
    }

    if (metadata.name.length > CHECKPOINT_CONFIG.maxNameLength) {
      throw new Error(`Checkpoint name too long (max ${CHECKPOINT_CONFIG.maxNameLength} characters)`);
    }

    if (metadata.description && metadata.description.length > CHECKPOINT_CONFIG.maxDescriptionLength) {
      throw new Error(`Checkpoint description too long (max ${CHECKPOINT_CONFIG.maxDescriptionLength} characters)`);
    }

    // Validate workspace state structure if requested
    if (options.validateState !== false) {
      const requiredArrays = ['terminalState', 'browserTabs', 'aiConversations', 'openFiles'];
      for (const arrayField of requiredArrays) {
        if (!Array.isArray((workspaceState as any)[arrayField])) {
          throw new TypeError(`Workspace state missing required array: ${arrayField}`);
        }
      }
    }

    // Validate encryption settings
    if (options.encryptData && (!options.encryptionKey || typeof options.encryptionKey !== 'string' || options.encryptionKey.trim() === '')) {
      throw new Error('Encryption key is required when encryptData is true');
    }
  }

  /**
   * Find duplicate checkpoint
   * @param sessionId
   * @param name
   */
  private async findDuplicateCheckpoint(sessionId: string, name: string): Promise<any> {
    return await prisma.sessionCheckpoint.findFirst({
      where: {
        sessionId,
        name
      }
    });
  }

  /**
   * Remove oldest checkpoint for a session
   * @param sessionId
   */
  private async removeOldestCheckpoint(sessionId: string): Promise<void> {
    const oldestCheckpoint = await prisma.sessionCheckpoint.findFirst({
      where: { sessionId },
      orderBy: { createdAt: 'asc' },
      select: { id: true }
    });

    if (oldestCheckpoint) {
      await prisma.sessionCheckpoint.delete({
        where: { id: oldestCheckpoint.id }
      });
    }
  }

  /**
   * Serialize workspace state
   * @param workspaceState
   * @param encrypt
   * @param encryptionKey
   */
  private async serializeWorkspaceState(
    workspaceState: WorkspaceState,
    encrypt = false,
    encryptionKey?: string
  ): Promise<{
    data: string;
    compressedSize: number;
    uncompressedSize: number;
  }> {
    try {
      const serializedState = JSON.stringify(workspaceState);
      const uncompressedSize = Buffer.byteLength(serializedState, 'utf8');

      if (encrypt && encryptionKey) {
        // Encrypt the data
        const encrypted = await this.serializer.encryptState(serializedState, encryptionKey);
        if (!encrypted || encrypted.data === undefined || encrypted.data === null) {
          throw new Error('Encryption failed to produce valid data');
        }
        return {
          data: encrypted.data,
          compressedSize: Buffer.byteLength(encrypted.data, 'base64'),
          uncompressedSize
        };
      } else {
        // Compress (or just encode) the data
        const compressed = await this.serializer.compressState(serializedState);
        if (!compressed || compressed.data === undefined || compressed.data === null) {
          throw new Error('Compression failed to produce valid data');
        }
        return {
          data: compressed.data,
          compressedSize: Buffer.byteLength(compressed.data, 'base64'),
          uncompressedSize
        };
      }
    } catch (error) {
      throw new Error(`Failed to serialize workspace state: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get current session state
   * @param sessionId
   */
  private async getCurrentSessionState(sessionId: string): Promise<WorkspaceState | null> {
    try {
      const session = await prisma.workspaceSession.findUnique({
        where: { id: sessionId },
        select: { workspaceState: true }
      });

      if (!session || !session.workspaceState) {
        return null;
      }

      return JSON.parse(session.workspaceState as string);
    } catch {
      return null;
    }
  }

  /**
   * Update session checkpoint count
   * @param sessionId
   */
  private async updateSessionCheckpointCount(sessionId: string): Promise<void> {
    const count = await prisma.sessionCheckpoint.count({
      where: { sessionId }
    });

    await prisma.sessionMetadata.upsert({
      where: { sessionId },
      update: { checkpointCount: count },
      create: {
        sessionId,
        checkpointCount: count,
        isActive: true,
        lastSavedAt: new Date()
      }
    });
  }

  /**
   * Map Prisma checkpoint to response format
   * @param checkpoint
   */
  private mapToCheckpointResponse(checkpoint: any): CheckpointResponse {
    return {
      id: checkpoint.id,
      sessionId: checkpoint.sessionId,
      name: checkpoint.name,
      description: checkpoint.description,
      createdAt: checkpoint.createdAt,
      compressedSize: checkpoint.compressedSize,
      uncompressedSize: checkpoint.uncompressedSize,
      tags: checkpoint.tags,
      priority: checkpoint.priority,
      isAutoGenerated: checkpoint.isAutoGenerated,
      metadata: checkpoint.metadata,
      session: checkpoint.session ? {
        id: checkpoint.session.id,
        name: checkpoint.session.name,
        workspaceId: checkpoint.session.workspaceId
      } : undefined
    };
  }

  /**
   * Map Prisma session to response format
   * @param session
   */
  private mapToSessionResponse(session: any): SessionResponse {
    return {
      id: session.id,
      userId: session.userId,
      workspaceId: session.workspaceId,
      name: session.name,
      isActive: session.isActive,
      lastSavedAt: session.lastSavedAt,
      expiresAt: session.expiresAt,
      createdAt: session.createdAt,
      checkpointCount: 0, // Will be calculated separately if needed
      totalSize: 0 // Will be calculated separately if needed
    };
  }
}

/**
 * Default checkpoint service instance
 */
export const sessionCheckpointService = new SessionCheckpointService();

/**
 * Create a new checkpoint service instance with custom configuration
 * @param config
 */
export function createSessionCheckpointService(
  config?: Partial<typeof CHECKPOINT_CONFIG>
): SessionCheckpointService {
  return new SessionCheckpointService(config);
}