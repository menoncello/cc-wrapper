import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

import { useSessionStore } from './session-store';
import type { Checkpoint } from './session-types';

// Mock fetch
global.fetch = vi.fn() as any;

// Test fixtures
const mockSession = {
  id: 'session-123',
  userId: 'user-123',
  workspaceId: 'workspace-123',
  name: 'Test Session',
  isActive: true,
  lastSavedAt: '2023-12-01T10:00:00Z',
  createdAt: '2023-12-01T09:00:00Z',
  checkpointCount: 0,
  totalSize: 0
};

const mockWorkspaceState = {
  terminalState: [],
  browserTabs: [],
  aiConversations: [],
  openFiles: [],
  workspaceConfig: {},
  metadata: {}
};

// Setup functions
const setupTestEnvironment = () => {
  vi.clearAllMocks();
  // Reset store state to initial state
  useSessionStore.getState().clearSession();
  useSessionStore.getState().setCurrentSession(mockSession);
  useSessionStore.getState().setWorkspaceState(mockWorkspaceState);
};

describe('sessionStore - Checkpoint Management', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });
});

describe('sessionStore - createCheckpoint', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should create checkpoint successfully', async () => {
    const mockResponse = {
      ok: true,
      json: vi.fn().mockResolvedValue({
        data: { id: 'checkpoint-123', name: 'Test Checkpoint' }
      })
    };
    (fetch as any).mockResolvedValue(mockResponse);

    const result = await useSessionStore.getState().createCheckpoint('Test Checkpoint', {
      description: 'Test description',
      tags: ['test'],
      priority: 'high',
      encryptData: false
    });

    expect(result).toBe('checkpoint-123');
    expect(fetch).toHaveBeenCalledWith('/api/checkpoints/v1', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionId: 'session-123',
        name: 'Test Checkpoint',
        description: 'Test description',
        tags: ['test'],
        priority: 'high',
        workspaceState: mockWorkspaceState,
        encryptData: false,
        encryptionKey: undefined,
        skipDuplicates: true
      })
    });

    expect(useSessionStore.getState().isCreatingCheckpoint).toBe(false);
  });

  it('should throw error when creating checkpoint without session', async () => {
    useSessionStore.getState().setCurrentSession(null);

    await expect(useSessionStore.getState().createCheckpoint('Test Checkpoint')).rejects.toThrow(
      'No active session to checkpoint'
    );
  });

  it('should throw error when creating checkpoint without workspace state', async () => {
    useSessionStore.getState().setWorkspaceState(null);

    await expect(useSessionStore.getState().createCheckpoint('Test Checkpoint')).rejects.toThrow(
      'No active session to checkpoint'
    );
  });
});

describe('sessionStore - createCheckpoint Error Handling', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should handle checkpoint creation API error', async () => {
    const mockResponse = {
      ok: false,
      json: vi.fn().mockResolvedValue({ error: 'API Error' })
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(useSessionStore.getState().createCheckpoint('Test Checkpoint')).rejects.toThrow(
      'API Error'
    );

    expect(useSessionStore.getState().isCreatingCheckpoint).toBe(false);
  });

  it('should handle checkpoint creation API error without error message', async () => {
    const mockResponse = {
      ok: false,
      json: vi.fn().mockResolvedValue({})
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(useSessionStore.getState().createCheckpoint('Test Checkpoint')).rejects.toThrow(
      'Failed to create checkpoint'
    );

    expect(useSessionStore.getState().isCreatingCheckpoint).toBe(false);
  });
});

describe('sessionStore - loadCheckpoints', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should load checkpoints successfully', async () => {
    const mockCheckpoints = [
      {
        id: 'checkpoint-1',
        sessionId: 'session-123',
        name: 'Checkpoint 1',
        createdAt: '2023-12-01T10:00:00Z',
        compressedSize: 1024,
        uncompressedSize: 2048,
        tags: [],
        priority: 'medium' as const,
        isAutoGenerated: false,
        metadata: {}
      }
    ];

    const mockResponse = {
      ok: true,
      json: vi.fn().mockResolvedValue({
        data: { checkpoints: mockCheckpoints }
      })
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await useSessionStore.getState().loadCheckpoints({ sessionId: 'session-123' });

    expect(fetch).toHaveBeenCalled();
    expect(useSessionStore.getState().checkpoints).toEqual(mockCheckpoints);
    expect(useSessionStore.getState().isLoadingCheckpoints).toBe(false);
  });

  it('should handle load checkpoints API error', async () => {
    const mockResponse = {
      ok: false
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(
      useSessionStore.getState().loadCheckpoints({ sessionId: 'session-123' })
    ).rejects.toThrow('Failed to load checkpoints');

    expect(useSessionStore.getState().isLoadingCheckpoints).toBe(false);
  });
});

describe('sessionStore - deleteCheckpoint', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should delete checkpoint successfully', async () => {
    const mockResponse = { ok: true };
    (fetch as any).mockResolvedValue(mockResponse);

    const checkpointToDelete = {
      id: 'checkpoint-123',
      sessionId: 'session-123',
      name: 'To Delete',
      createdAt: '2023-12-01T10:00:00Z',
      compressedSize: 1024,
      uncompressedSize: 2048,
      tags: [],
      priority: 'medium' as const,
      isAutoGenerated: false,
      metadata: {}
    };

    useSessionStore.setState({
      checkpoints: [checkpointToDelete]
    });

    await useSessionStore.getState().deleteCheckpoint('checkpoint-123');

    expect(fetch).toHaveBeenCalledWith('/api/checkpoints/v1/checkpoint-123', {
      method: 'DELETE'
    });
    expect(useSessionStore.getState().checkpoints).not.toContainEqual(checkpointToDelete);
  });

  it('should handle delete checkpoint API error', async () => {
    const mockResponse = {
      ok: false,
      json: vi.fn().mockResolvedValue({ error: 'Delete failed' })
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(useSessionStore.getState().deleteCheckpoint('checkpoint-123')).rejects.toThrow(
      'Delete failed'
    );
  });

  it('should handle delete checkpoint API error without error message', async () => {
    const mockResponse = {
      ok: false,
      json: vi.fn().mockResolvedValue({})
    };
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(useSessionStore.getState().deleteCheckpoint('checkpoint-123')).rejects.toThrow(
      'Failed to delete checkpoint'
    );
  });
});

describe('sessionStore - updateCheckpointMetadata', () => {
  beforeEach(setupTestEnvironment);

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should update checkpoint metadata successfully', async () => {
    const mockCheckpoint = createMockUpdatedCheckpoint();
    const mockResponse = createMockUpdateResponse(mockCheckpoint);
    (fetch as any).mockResolvedValue(mockResponse);

    setupExistingCheckpoint();

    const result = await useSessionStore.getState().updateCheckpointMetadata('checkpoint-123', {
      name: 'Updated Checkpoint',
      tags: ['updated'],
      priority: 'high'
    });

    expect(result).toBeUndefined();
    verifyUpdateRequest(mockCheckpoint);
    verifyCheckpointUpdated(mockCheckpoint);
  });

  it('should handle update checkpoint metadata API error', async () => {
    const mockResponse = createMockUpdateErrorResponse();
    (fetch as any).mockResolvedValue(mockResponse);

    await expect(
      useSessionStore.getState().updateCheckpointMetadata('checkpoint-123', {
        name: 'Updated Checkpoint'
      })
    ).rejects.toThrow('Update failed');
  });
});

// Helper functions for updateCheckpointMetadata tests
function createMockUpdatedCheckpoint() {
  return {
    id: 'checkpoint-123',
    sessionId: 'session-123',
    name: 'Updated Checkpoint',
    createdAt: '2023-12-01T10:00:00Z',
    compressedSize: 1024,
    uncompressedSize: 2048,
    tags: ['updated'],
    priority: 'high' as const,
    isAutoGenerated: false,
    metadata: {}
  };
}

function createMockUpdateResponse(mockCheckpoint: Checkpoint) {
  return {
    ok: true,
    json: vi.fn().mockResolvedValue({
      data: mockCheckpoint
    })
  };
}

function createMockUpdateErrorResponse() {
  return {
    ok: false,
    json: vi.fn().mockResolvedValue({ error: 'Update failed' })
  };
}

function setupExistingCheckpoint() {
  useSessionStore.setState({
    checkpoints: [
      {
        id: 'checkpoint-123',
        sessionId: 'session-123',
        name: 'Old Checkpoint',
        createdAt: '2023-12-01T10:00:00Z',
        compressedSize: 1024,
        uncompressedSize: 2048,
        tags: ['old'],
        priority: 'medium' as const,
        isAutoGenerated: false,
        metadata: {}
      }
    ]
  });
}

function verifyUpdateRequest(_mockCheckpoint: Checkpoint) {
  expect(fetch).toHaveBeenCalledWith('/api/checkpoints/v1/checkpoint-123', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      name: 'Updated Checkpoint',
      tags: ['updated'],
      priority: 'high'
    })
  });
}

function verifyCheckpointUpdated(mockCheckpoint: Checkpoint) {
  const state = useSessionStore.getState();
  expect(state.checkpoints[0]).toEqual(mockCheckpoint);
}
