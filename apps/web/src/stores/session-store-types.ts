// Type declarations for global scope interval management
declare global {
  var __sessionAutoSaveInterval: ReturnType<typeof setInterval> | undefined;
}

// Type aliases for common patterns
export type SortField = 'createdAt' | 'name' | 'size' | 'priority' | string;
export type SortOrder = 'asc' | 'desc' | string;
export type CheckpointPriority = 'low' | 'medium' | 'high';

// Types for session management
export interface WorkspaceState {
  terminalState: unknown[];
  browserTabs: unknown[];
  aiConversations: unknown[];
  openFiles: unknown[];
  workspaceConfig?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
}

export interface Session {
  id: string;
  userId: string;
  workspaceId: string;
  name: string;
  isActive: boolean;
  lastSavedAt: string;
  expiresAt?: string;
  createdAt: string;
  checkpointCount: number;
  totalSize: number;
}

export interface Checkpoint {
  id: string;
  sessionId: string;
  name: string;
  description?: string;
  createdAt: string;
  compressedSize: number;
  uncompressedSize: number;
  tags: string[];
  priority: CheckpointPriority;
  isAutoGenerated: boolean;
  metadata?: Record<string, unknown>;
  session?: {
    id: string;
    name: string;
    workspaceId: string;
  };
}

export interface CheckpointFilter {
  sessionId?: string;
  tags?: string[];
  dateFrom?: Date;
  dateTo?: Date;
  priority?: CheckpointPriority;
  isAutoGenerated?: boolean;
  limit?: number;
  offset?: number;
  sortBy?: SortField;
  sortOrder?: SortOrder;
}

interface SessionState {
  // Current session state
  currentSession: Session | null;
  workspaceState: WorkspaceState | null;
  isDirty: boolean;
  lastSaved: Date | null;
  autoSaveEnabled: boolean;
  autoSaveInterval: number;

  // Checkpoints
  checkpoints: Checkpoint[];
  checkpointFilter: CheckpointFilter;
  isLoadingCheckpoints: boolean;

  // UI state
  isCreatingCheckpoint: boolean;
  isRestoringCheckpoint: boolean;
  checkpointName: string;
  checkpointDescription: string;
  checkpointTags: string[];
  checkpointPriority: CheckpointPriority;

  // Actions
  /**
   * Sets the current active session
   * @param {Session | null} session - The session to set as current, or null to clear
   * @returns {void}
   */
  setCurrentSession: (session: Session | null) => void;

  /**
   * Sets the current workspace state
   * @param {WorkspaceState | null} state - The workspace state to set, or null to clear
   * @returns {void}
   */
  setWorkspaceState: (state: WorkspaceState | null) => void;

  /**
   * Updates the current workspace state with partial updates
   * @param {Partial<WorkspaceState>} updates - Partial workspace state updates to merge
   * @returns {void}
   */
  updateWorkspaceState: (updates: Partial<WorkspaceState>) => void;

  /**
   * Sets the dirty state of the current session
   * @param {boolean} dirty - Whether the session has unsaved changes
   * @returns {void}
   */
  setDirty: (dirty: boolean) => void;

  /**
   * Configures auto-save settings
   * @param {boolean} enabled - Whether auto-save should be enabled
   * @param {number} [interval] - Optional custom auto-save interval in milliseconds
   * @returns {void}
   */
  setAutoSave: (enabled: boolean, interval?: number) => void;

  // Checkpoint management
  /**
   * Creates a new checkpoint for the current session
   * @param {string} name - The name of the checkpoint
   * @param {object} [options] - Optional configuration for the checkpoint
   * @param {string} [options.description] - Optional description of the checkpoint
   * @param {string[]} [options.tags] - Optional array of tags for the checkpoint
   * @param {'low' | 'medium' | 'high'} [options.priority] - Optional priority level (low, medium, high)
   * @param {boolean} [options.encryptData] - Whether to encrypt the checkpoint data
   * @param {string} [options.encryptionKey] - Optional encryption key for the checkpoint
   * @returns {Promise<string>} Promise resolving to the created checkpoint ID
   */
  createCheckpoint: (
    name: string,
    options?: {
      description?: string;
      tags?: string[];
      priority?: CheckpointPriority;
      encryptData?: boolean;
      encryptionKey?: string;
    }
  ) => Promise<string>;

  /**
   * Loads checkpoints from the server with optional filtering
   * @param {CheckpointFilter} [filter] - Optional filter criteria for loading checkpoints
   * @returns {Promise<void>} Promise that resolves when checkpoints are loaded
   */
  loadCheckpoints: (filter?: CheckpointFilter) => Promise<void>;

  /**
   * Restores a checkpoint to become the current session state
   * @param {string} checkpointId - The ID of the checkpoint to restore
   * @param {object} [options] - Optional restore configuration
   * @param {boolean} [options.createBackup] - Whether to create a backup before restoring
   * @param {string} [options.backupName] - Optional name for the backup
   * @param {string} [options.encryptionKey] - Optional encryption key for the checkpoint
   * @returns {Promise<boolean>} Promise resolving to true if restore was successful
   */
  restoreCheckpoint: (
    checkpointId: string,
    options?: {
      createBackup?: boolean;
      backupName?: string;
      encryptionKey?: string;
    }
  ) => Promise<boolean>;

  /**
   * Deletes a checkpoint
   * @param {string} checkpointId - The ID of the checkpoint to delete
   * @returns {Promise<void>} Promise that resolves when checkpoint is deleted
   */
  deleteCheckpoint: (checkpointId: string) => Promise<void>;

  /**
   * Updates metadata for an existing checkpoint
   * @param {string} checkpointId - The ID of the checkpoint to update
   * @param {object} updates - The metadata updates to apply
   * @param {string} [updates.name] - Optional new name for the checkpoint
   * @param {string} [updates.description] - Optional new description for the checkpoint
   * @param {string[]} [updates.tags] - Optional new array of tags for the checkpoint
   * @param {'low' | 'medium' | 'high'} [updates.priority] - Optional new priority level
   * @returns {Promise<void>} Promise that resolves when metadata is updated
   */
  updateCheckpointMetadata: (
    checkpointId: string,
    updates: {
      name?: string;
      description?: string;
      tags?: string[];
      priority?: 'low' | 'medium' | 'high';
    }
  ) => Promise<void>;

  // Session persistence
  /**
   * Saves the current session state to the server
   * @param {object} [options] - Optional save configuration
   * @param {boolean} [options.force] - Whether to force save even if not dirty
   * @returns {Promise<boolean>} Promise resolving to true if save was successful
   */
  saveSession: (options?: { force?: boolean }) => Promise<boolean>;

  /**
   * Restores a session from the server
   * @param {string} sessionId - The ID of the session to restore
   * @param {object} [options] - Optional restore configuration
   * @param {string} [options.encryptionKey] - Optional encryption key for the session
   * @param {boolean} [options.createBackup] - Whether to create a backup before restoring
   * @returns {Promise<boolean>} Promise resolving to true if restore was successful
   */
  restoreSession: (
    sessionId: string,
    options?: {
      encryptionKey?: string;
      createBackup?: boolean;
    }
  ) => Promise<boolean>;

  /**
   * Creates a new session with the provided configuration
   * @param {object} config - Configuration for the new session
   * @param {string} config.userId - The user ID creating the session
   * @param {string} config.workspaceId - The workspace ID for the session
   * @param {string} config.name - The name of the session
   * @param {WorkspaceState} config.workspaceState - The initial workspace state
   * @param {string} [config.encryptionKey] - Optional encryption key for the session
   * @returns {Promise<string>} Promise resolving to the created session ID
   */
  createNewSession: (config: {
    userId: string;
    workspaceId: string;
    name: string;
    workspaceState: WorkspaceState;
    encryptionKey?: string;
  }) => Promise<string>;

  // Auto-save functionality
  /**
   * Starts the auto-save interval for the current session
   * @returns {void}
   */
  startAutoSave: () => void;

  /**
   * Stops the auto-save interval for the current session
   * @returns {void}
   */
  stopAutoSave: () => void;

  // UI helpers
  /**
   * Sets the checkpoint form data with partial updates
   * @param {object} data - The form data to update
   * @param {string} [data.name] - Optional checkpoint name
   * @param {string} [data.description] - Optional checkpoint description
   * @param {string[]} [data.tags] - Optional array of tags
   * @param {'low' | 'medium' | 'high'} [data.priority] - Optional priority level
   * @returns {void}
   */
  setCheckpointForm: (data: {
    name?: string;
    description?: string;
    tags?: string[];
    priority?: 'low' | 'medium' | 'high';
  }) => void;

  /**
   * Resets the checkpoint form to default values
   * @returns {void}
   */
  resetCheckpointForm: () => void;

  /**
   * Clears the current session and resets all related state
   * @returns {void}
   */
  clearSession: () => void;
}

export type { SessionState };
